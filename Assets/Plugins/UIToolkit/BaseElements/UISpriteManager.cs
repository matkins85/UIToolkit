/*
	Many thanks to the excellent work of Brady Wright from Above and Beyond Software for providing the community with the
	amazing SpriteManager back in the day.  A few bits of his original code are buried somewhere in here.  Be sure to check
	out his amazing products in the Unity Asset Store.
	http://forum.unity3d.com/threads/16763-SpriteManager-draw-lots-of-sprites-in-a-single-draw-call!?highlight=spritemanager
*/
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;



public struct UITextureInfo
{
	public UIUVRect uvRect;
	public Vector2 size;
	public Rect frame;
}


public class UISpriteManager : MonoBehaviour 
{

	#region ivars
	
	public GameObject uiElementPrefab;
	
	// if set to true, the texture will be chosen and loaded from textureName
	// the base texture to use. If HD/retina, textureName2x will be loaded.  Both need to be in Resources.
	// this also doubles as the name of the json config file generated by Texture Packer
	public bool autoTextureSelectionForHD = false;
	public bool allowPod4GenHD = true; // if false, iPod touch 4G will not take part in HD mode
	public string texturePackerConfigName;
	[HideInInspector]
	public bool isHD = false;
	
	protected UISprite[] sprites = new UISprite[20];    // Array of all sprites (the offset of the vertices corresponding to each sprite should be found simply by taking the sprite's index * 4 (4 verts per sprite).
	protected Texture texture;
	public Material material;
	
	[HideInInspector]
	public Vector2 textureSize = Vector2.zero;

	
	protected Dictionary<string, UITextureInfo> textureDetails; // texture details loaded from the TexturePacker config file

	#endregion;
	

	#region Unity MonoBehaviour Functions
	
    virtual protected void Awake()
    {
        // Move the object to the origin so the objects drawn will not be offset from the objects they are intended to represent.
        transform.position = Vector3.zero;
        transform.rotation = Quaternion.identity;

		// handle texture loading if required
		var deviceAllowsHD = ( allowPod4GenHD && iPhoneSettings.generation == iPhoneGeneration.iPodTouch4Gen ) || iPhoneSettings.generation != iPhoneGeneration.iPodTouch4Gen;
		if( autoTextureSelectionForHD && deviceAllowsHD )
		{
			// are we laoding up a 2x texture?
#if UNITY_EDITOR
			if( Screen.width >= 500 || Screen.height >= 500 ) // for easier testing in the editor
#else
			if( Screen.width >= 960 || Screen.height >= 960 )
#endif
			{
#if UNITY_EDITOR
				Debug.Log( "switching to 2x GUI texture" );
#endif
				texturePackerConfigName = texturePackerConfigName + "2x";
				isHD = true;
			}
		}

		// load our texture		
		var texture = (Texture)Resources.Load( texturePackerConfigName, typeof( Texture ) );
		if( texture == null )
			Debug.Log( "UI texture is being autoloaded and it doesnt exist: " + texturePackerConfigName );
		material.SetTexture( "_MainTex", texture );
		
		// Cache our texture size
		Texture t = material.GetTexture( "_MainTex" );
		textureSize = new Vector2( t.width, t.height );
		
		// load up the config file
		textureDetails = loadTexturesFromTexturePackerJSON( texturePackerConfigName + ".json" );
    }
	
	#endregion;
	
	
	#region Texture management
	
	private Dictionary<string, UITextureInfo> loadTexturesFromTexturePackerJSON( string filename )
	{
		var textures = new Dictionary<string, UITextureInfo>();
		
		string jsonConfigFile = Application.dataPath;
	
#if UNITY_EDITOR
		jsonConfigFile = jsonConfigFile.Substring( 0, jsonConfigFile.Length ) + "/StreamingAssets/" + filename;

		// sanity check while in the editor
		if( !System.IO.File.Exists( jsonConfigFile ) )
			throw new Exception( "texture packer config file doesnt exist: " + jsonConfigFile );
#elif UNITY_ANDROID

		/* this wont work because we can't get a byte[] to pass on to the input stream */
		AndroidJNIHelper.debug = true;
		
		// getting the cache dir
		AndroidJavaObject jc = new AndroidJavaClass( "com.unity3d.player.UnityPlayer" );
		AndroidJavaObject jo = jc.GetStatic<AndroidJavaObject>( "currentActivity" );
		
		// getting a streaming asset
		AndroidJavaObject assetManager = jo.Call<AndroidJavaObject>( "getAssets" );
		AndroidJavaObject inputStream = assetManager.Call<AndroidJavaObject>( "open", "test.json" );
		int streamSize = inputStream.Call<int>( "available" );
		Debug.Log( ">>>>>>>>>>>>>>>>>> log streamSize: " + streamSize );
		
		
		/*
		var javaBytes = AndroidJNI.NewByteArray( streamSize );

		int numRead = inputStream.Call<int>( "read", javaBytes );
		var monoBytes = AndroidJNI.FromByteArray( javaBytes );
		
		Debug.Log( ">>>>>>>>>>>>>>>>>> total read: " + numRead );
		Debug.Log( ">>>>>>>>>>>>>>>>>> first byte: " + monoBytes[0] );
		Debug.Log( ">>>>>>>>>>>>>>>>>> first byte: " + monoBytes[1] );
		Debug.Log( ">>>>>>>>>>>>>>>>>> first byte: " + monoBytes[2] );
		Debug.Log( ">>>>>>>>>>>>>>>>>> final fileContents: " + System.Text.ASCIIEncoding.ASCII.GetString( monoBytes ) );
		Debug.Log( ">>>>>>>>>>>>>>>>>> final fileContents: " + System.Text.UTF8Encoding.UTF8.GetString( monoBytes ) );
		*/
		
		
		// Read in the bytes
		int i = 0;
		int numRead = 0;
		var sb = new System.Text.StringBuilder();
		
		do
		{
			numRead = inputStream.Call<int>( "read", javaBytes );

			if( numRead >= 0 )
				sb.Append( (char)numRead );
		}
		while( numRead >= 0 );
		
		inputStream.Call( "close" );
		
		Debug.Log( ">>>>>>>>>>>>>>>>>> read in file: " + sb.ToString() );
		
		
		/*
		do
		{
			Debug.Log( ">>>>>>>>>>>>>>>>>> bytesRead: " + numRead );
			numRead = inputStream.Call<int>( "read", javaBytes );
		}
		while( numRead >= 0 );
		Debug.Log( ">>>>>>>>>>>>>>>>>> bytesRead: " + numRead );
						
		//var bytesRead = inputStream.Call<int>( "read", javaBytes );
		//Debug.Log( ">>>>>>>>>>>>>>>>>> bytesRead: " + bytesRead );
		

		//var monoBytes = AndroidJNI.FromByteArray( javaBytes );
		Debug.Log( ">>>>>>>>>>>>>>>>>> Mono bytes length: " + monoBytes.Length );
		Debug.Log( ">>>>>>>>>>>>>>>>>> Mono bytes: " + monoBytes[0] );
		
		var fileContents = System.Text.UTF8Encoding.UTF8.GetString( monoBytes );
		Debug.Log( ">>>>>>>>>>>>>>>>>> final fileContents: " + fileContents );
		Debug.Log( ">>>>>>>>>>>>>>>>>> final fileContents: " + System.Text.ASCIIEncoding.ASCII.GetString( monoBytes ) );
		*/
		
		
		// Doesnt work!!!
		jsonConfigFile = "jar:file://" + Application.dataPath + "!/assets/" + filename;
#else
		jsonConfigFile = jsonConfigFile + "/Raw/" + filename;
#endif
	
		using( var sr = new System.IO.StreamReader( jsonConfigFile ) )
		{
			var jsonString = sr.ReadToEnd();
			var decodedHash = (Hashtable)MiniJSON.JsonDecode( jsonString );
			var frames = (Hashtable)decodedHash["frames"];
		
			foreach( System.Collections.DictionaryEntry item in frames )
			{
				// extract the info we need from the TexturePacker json file.  mainly uvRect and size
				var sourceSize = (Hashtable)((Hashtable)item.Value)["sourceSize"];
				var frame = (Hashtable)((Hashtable)item.Value)["frame"];
				var frameX = int.Parse( frame["x"].ToString() );
				var frameY = int.Parse( frame["y"].ToString() );
				var frameW = int.Parse( frame["w"].ToString() );
				var frameH = int.Parse( frame["h"].ToString() );
			
				var ti = new UITextureInfo();
				ti.frame = new Rect( frameX, frameY, frameW, frameH );
				ti.size = new Vector2( float.Parse( sourceSize["w"].ToString() ), float.Parse( sourceSize["h"].ToString() ) );
				ti.uvRect = new UIUVRect( frameX, frameY, frameW, frameH );
			
				textures.Add( item.Key.ToString(), ti );
			}
		}
		
		return textures;
	}
	
	
	// grabs the UITextureInfo for the given filename
	public UITextureInfo textureInfoForFilename( string filename )
	{
#if UNITY_EDITOR
		// sanity check while in editor
		if( !textureDetails.ContainsKey( filename ) )
			throw new Exception( "can't find texture details for texture packer sprite:" + filename );
#endif
		return textureDetails[filename];
	}
	
	
	// grabs the uvRect for the given filename
	public UIUVRect uvRectForFilename( string filename )
	{
#if UNITY_EDITOR
		// sanity check while in editor
		if( !textureDetails.ContainsKey( filename ) )
			throw new Exception( "can't find texture details for texture packer sprite:" + filename );
#endif
		return textureDetails[filename].uvRect;
	}
		
		
	// grabs the frame for the given filename
	public Rect frameForFilename( string filename )
	{
#if UNITY_EDITOR
		// sanity check while in editor
		if( !textureDetails.ContainsKey( filename ) )
			throw new Exception( "can't find texture details for texture packer sprite:" + filename );
#endif
		return textureDetails[filename].frame;
	}


	// grabs the width for the given filename, useful when using the UIRelative class
	public float widthForFilename( string filename )
	{
#if UNITY_EDITOR
		// sanity check while in editor
		if( !textureDetails.ContainsKey( filename ) )
			throw new Exception( "can't find texture details for texture packer sprite:" + filename );
#endif
		return textureDetails[filename].size.x;
	}


	// grabs the height for the given filename, useful when using the UIRelative class
	public float heightForFilename( string filename )
	{
#if UNITY_EDITOR
		// sanity check while in editor
		if( !textureDetails.ContainsKey( filename ) )
			throw new Exception( "can't find texture details for texture packer sprite:" + filename );
#endif
		return textureDetails[filename].size.y;
	}
	
	#endregion
	

	#region Add/Remove sprite functions

    public UISprite addSprite( string name, int xPos, int yPos, int depth = 1, bool gameObjectOriginInCenter = false )
    {
#if UNITY_EDITOR
		// sanity check while in editor
		if( !textureDetails.ContainsKey( name ) )
			throw new Exception( "can't find texture details for texture packer sprite:" + name );
#endif
		var textureInfo = textureDetails[name];
		var positionRect = new Rect( xPos, yPos, textureInfo.size.x, textureInfo.size.y );

		return this.addSprite( positionRect, textureInfo.uvRect, depth, gameObjectOriginInCenter );
    }

	
	// shortcut for adding a new sprite using the raw materials
    private UISprite addSprite( Rect frame, UIUVRect uvFrame, int depth, bool gameObjectOriginInCenter = false )
    {
        // Create and initialize the new sprite
		UISprite newSprite = new UISprite( frame, depth, uvFrame, gameObjectOriginInCenter );        
		addSprite( newSprite );
		
		return newSprite;
    }


    // Adds a sprite to the manager
    public void addSprite( UISprite sprite )
    {
        // Initialize the new sprite and update the UVs		
		int i = 0;
	
		// Find the first available sprite index
		for( ; i < sprites.Length; i++ )
		{
			if( sprites[i] == null )
				break;
		}
		
		// did we find a sprite?  if not, expand our arrays
        UISprite[] tempSprites = sprites;
        sprites = new UISprite[sprites.Length + 5];
        tempSprites.CopyTo( sprites, 0 );
        i = tempSprites.Length;

        // Assign and setup the sprite
		sprites[i] = sprite;
		
        sprite.index = i;
        sprite.manager = this;
    }


    protected void removeSprite( UISprite sprite )
    {
    	sprites[sprite.index] = null;
		
		// This should happen when the sprite dies but it doesnt!!
		Destroy( sprite.client );
    }

	#endregion;


}
